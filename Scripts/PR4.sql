--Задание 1
--18) Вывести продукт,  дату поставки и отпускную цену поставок где продукты поставлялись дешевле чем за 1000
SELECT product_name, delivery_day, price_sale_in FROM product_deliv JOIN product ON product_deliv.product_id = product.id WHERE price_sale_out < 1000;

--Задание 2
--9) Выбрать из таблицы Сотрудников Департамент и зарплату + НДФЛ (13%) из департаменты IT
SELECT "Name", departament, salary*1.13 AS salary_with_ndfl FROM employers WHERE departament = 'IT';

--Задание 3
--8) Выбрать из таблицы Продуктов найти магазин и дату ревизии с наибольшей общей стоимостью всех  товаров
SELECT shop_id, revizion_date, total from (SELECT shop_id, revizion_date, sum(count * price_sale_out) AS total FROM product GROUP BY shop_id, revizion_date) AS t JOIN (
	SELECT max(total) AS maxtotal FROM
	(SELECT shop_id, revizion_date, sum(count * price_sale_out) AS total  
	FROM product 
	JOIN shops ON shops.id = product.shop_id 
	GROUP BY shop_id, revizion_date)) AS mp2
ON mp2.maxtotal=t.total;

--Задание 4
--4) Вывести для каждой записи ревизии продукт, дату, магазин и поставщика товара
SELECT product_name, revizion_date, market_name, name FROM product JOIN shops ON product.shop_id = shops.id JOIN product_deliv ON product.id = product_deliv.product_id AND product.shop_id = product_deliv.shop_id JOIN vendors ON product_deliv.vendor_id = vendors.id;

--Задание 5
--7) Вывести среднюю зарплату сотрудников в каждом городе
SELECT city, avg(salary) FROM employers JOIN shops ON employers.shop_id = shops.id GROUP BY city;

--Задание 6
--5) Вывести всех сотрудников тех кто получает больше средней зарплаты в своем городе пометить как "переплата" отсальные  - "зп по рынку"
SELECT "Name", shops.city, salary, average, CASE WHEN salary > average THEN 'Преплата' ELSE 'зп по рынку' END AS conclusion FROM employers JOIN shops ON employers.shop_id  = shops.id JOIN (SELECT city, avg(salary) AS average FROM employers JOIN shops ON employers.shop_id = shops.id GROUP BY city) AS avgs ON shops.city = avgs.city;

--Задание 7
--6) *Для каждого сотрудника вывести его базовый оклад и текущую зарплату
CREATE OR REPLACE FUNCTION get_base_and_actual_salary() RETURNS void AS $$
BEGIN
	CREATE SCHEMA IF NOT EXISTS func;
	DROP TABLE IF EXISTS func.func7;
	CREATE TABLE func.func7
	(id int8 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	"Name" varchar(100) NOT NULL,
	base money NULL,
	salary float8 NULL,
	CONSTRAINT employers_pk PRIMARY KEY (id));
	INSERT INTO func.func7 (SELECT employers.id, "Name", base_cost, salary FROM bd_shops.employers JOIN (SELECT id, min(market_name) AS market_name, min("type") AS "type" FROM (SELECT *, LAST_VALUE(size_name) OVER (PARTITION BY id) AS "type" FROM bd_shops.shops JOIN bd_shops.market_size ON shops.square > min_square) GROUP BY id) AS tps ON employers.shop_id = tps.id JOIN bd_shops.market_board ON "type" = market_board.size_name ORDER BY employers.id);
END;
$$ LANGUAGE plpgsql;
SELECT get_base_and_actual_salary();

--Задание 8
--4) Посчитать для каждой ревизии(не записи ревизии) число разных  поставщиков товарного ассортимента
SELECT revizion_date, count(DISTINCT vendor_id) AS c FROM product JOIN product_deliv ON product.id = product_deliv.product_id AND product.shop_id = product_deliv.shop_id GROUP BY revizion_date ORDER BY revizion_date;